
\documentclass{article}
\usepackage[margin=2cm,bottom=2cm]{geometry}
\usepackage{hyperref}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\usepackage{setspace}
\usepackage{MnSymbol}
\usepackage{soul}

\newcommand\tab[1][1cm]{\hspace*{#1}}
\DeclareMathSizes{10}{10}{10}{10}

\begin{document}
\title{COMP/CMPE 314 - Principles of Programming Languages - Week12 Lecture Notes}
\author{Chris Stephenson, Istanbul Bilgi University, Department of Mathematics, and course students}
\section {Haskell} 

Has typing and type inference\\
What is the right hand side of cosSeries?\\
It is a list comprehension.\\
Aim is $\rightarrow$ 1-$x^2/2!$+$x^4/4!$.....\\
fact: Num a $\rightarrow$ Integer $\rightarrow$ a \\
fact x= fromIntegral(product + [1...x])\\
cosSeries :: Double $\rightarrow$ Integer $\rightarrow$ Double \\
cosSeries x$\mid$ = sum[(helperOfCos x i) | : $<$ - [0,2,...l]] \\
helperOfCos x i = if i 'mod' 4 == 0 then $(x\wedge i)$ $/$ (fact i) else - $(x\wedge i)$ $/$ (fact i) \\
integrate s = zipWith ($/$) s [1,2..] \\
funny = $|$: integrate funny \\
sums s= (head s): map((+)(head s))(sums(tail s)) \\
powers x = 1 : map (*x)(powers x) \\
sums [1,2...]=1,3,7.... \\
d$/$dx sinx = cosx \\
d$/$dx cosx = -sinx \\
$\int_{0}^{x} sinx dx$=1-cosx \\
$\int_{0}^{x} cosx dx$=sinx \\
sineSeries= 0: integrate cosSeries \\
cosSeries= 1:integrate (map negate sineSeries) \\
sinexSeries x = map (x $\wedge$ n) [0,1..] \\
sinexSeries = zipWith (*)(powers x) sineSeries \\
cosxSeries= zipWith (*)(powers x) cosSeries \\
facs= 1:zipWith(*) facs [2,3...] \\
fibs = 1:1:zipWith(+) fibs(tail fibs) \\
\section {ERATOSTHES SIEVE} 
isPrime :: [Integer]Integer $\rightarrow$ Bool \\
isPrime lp n = \\ 
$|$ (head l p)$\wedge$ 2 $>$ n = True\\
$|$ mod n (head l p) == 0 = False\\
$|$ Otherwise =isPrime (tail l p) n \\
Primes = 2 : (filter (isPrime primes) [3,5...]) \\
\section {TYPE SIGNATURES}
filter :: (a$\rightarrow$ Bool) $\rightarrow$ [a] $\rightarrow$ [a] \\
map :: (a $\rightarrow$ b) $\rightarrow$ [a] $\rightarrow$ [b] \\
foldr :: (a$\rightarrow$b$\rightarrow$b)$\rightarrow$b$\rightarrow$[a]$\rightarrow$b \\
sum = foldr (+) 0
product = foldr (*) 1 \\
Leveraging the Haskell type system = polynomial arithmetic\\
Instance num a $\rightarrow$ Num[a] where $(ph:pt)$+$(qh:qt)$=ph+qh:pt+qt \\ 
p + $[]$ = p \\
$[]$+ q = q \\

\end{document}